---
title: "Simplextree"
author: "Matt Piekenbrock"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the simplextree package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

`simplextree` is an [R](https://www.r-project.org/) package aimed at simplifying computation with general [simplicial complexes](https://en.wikipedia.org/wiki/Simplicial_complex) of any dimension by providing R-bindings to a _Simplex Tree_ data structure. These bindings are exported to the user in the form of an [Rcpp module](https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-modules.pdf), which interfaces modern [C++11](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf) that allows efficient manipulation of the data structure. 

The Simplex Tree data structure was originally introduced in the following paper: 

> Boissonnat, Jean-Daniel, and Cl√©ment Maria. "The simplex tree: An efficient data structure for general simplicial complexes." Algorithmica 70.3 (2014): 406-427.

A _Simplex Tree_ is an ordered, [trie](https://en.wikipedia.org/wiki/Trie)-like structure. Here's a picture of a simplicial complex (left) and its corresponding _Simplex Tree_ (right):

```{r, echo=FALSE, fig.width=2}
st_path <- system.file(package="simplextree")
fig_inst_path <- file.path(st_path, "doc", "simplextree_fig.pdf")
fig_path <- ifelse(file.exists(fig_inst_path), fig_inst_path, file.path("simplextree_fig.pdf"))
knitr::include_graphics(path = fig_path, auto_pdf = TRUE, dpi = 330)
```

## Quick tour of the package 

Create a simplex tree by calling `simplex_tree()`
```{r}
library("simplextree")
st <- simplex_tree()
```

Specify simplices as _vectors_.
```{r}
## Inserts the 2-simplex { 1, 2, 3 }. Also inserts its faces.
st$insert(c(1, 2, 3))
print(st)
```

Specify collections of simplices as _lists of vectors_
```{r}
## Inserts two 0-simplices, { 4 } and { 5 }, and one 1-simplex, { 5, 6 }
st$insert(list(4, 5, c(5, 6)))
print(st)
```
Finding and removing simplices are handled identically.  
```{r}
st$find(c(2, 3)) ## TRUE
st$remove(list(4, 5))
print(st)
```
A visual summary of the complex is available via the `print_tree` method
```{r}
print(st) # also see $dimension and $n_simplices
st$print_tree()
```
Querying the trie is handled largely through _traversals_. A traversal on a simplicial complex $K$ is an ordered path through a subset $S \subseteq K$. Traversals are specified with a simplex (optional), a unary function $f$ (required), and a traversal type string (required). If no simplex is specified, the traversal begins at the `empty_face`.  

For example, a depth-first traversal beginning at the empty face is achieved as follows:
<!-- The `simplextree` package allows arbitrary function evaluations on traversals.    -->
```{r}
st$traverse(print, "dfs") # equivalent to st$traverse(empty_face, print, "dfs")
```
Or to start the traversal at a simplex: 
```{r}
## Prints the cofaces of { 2 }
st$traverse(2L, print, "cofaces")
```
Some traversals require additional parameters. These must be passed via a named list, e.g.
```{r}
st$traverse(empty_face, print, "maximal-skeleton", list(k = 1L))
```
The results can also be collected in a list, similar to `lapply`
```{r}
## Get the simplices in the link of the 1-simplex { 2, 3 }
st$ltraverse(3, identity, "link")
```

Traversals can also be nested
```{r}
## Prints the cofaces of the 0-simplices
st$traverse(empty_face, function(simplex){ 
  cofaces <- st$ltraverse(simplex, identity, "cofaces")
  cat(sprintf("Cofaces of %s: %s\n", simplex, paste0(cofaces, collapse = ", ")))
}, "maximal-skeleton", list(k = 0))
```

A variety of topological operations, such as elementary collapses and edge contractions, k-expansions, etc. are supported.
```{r}
## Collapse the free pair ({ 3 }, { 6 }) -> { 6 }
st$collapse(3, 6, 6)
st$print_tree()
```

Additionally, simple serialization and persistent storage interfaces are available as well:
```{r}
st1 <- simplex_tree()
st2 <- simplex_tree()

## Inserts 11 simplices
st1$insert(list(1, 2, 3, c(1, 2), c(2, 3), c(1, 3), c(1, 2, 3), 4, 5, c(4, 5), 6))

## serialize exports the maximal faces needed to restore the complex 
st_serialized <- st1$serialize()
writeLines(paste0(st_serialized))

## deserializing inserts the faces
st2$deserialize(st_serialized)
all.equal(st1, st2)
```

That's a quick overview of the `simplextree` package. 

## More Information 

The reference API list contains. 


<!-- Why traversals, as opposed to object methods calls that simply return the traversal subset?  -->


<!-- There's a couple reasons for this, but the idea was loosely inspired by the discreture library, and the [movement of the larger C++ community](http://webcache.googleusercontent.com/search?q=cache:VOchK2XzFyAJ:ericniebler.com/2017/08/17/ranges-coroutines-and-react-early-musings-on-the-future-of-async-in-c/+&cd=1&hl=en&ct=clnk&gl=us).  -->

<!-- The first reason is that it's entirely possible that one might want to only operate on not just the subset perprogrammed by a traversal path, but a subset of that path itself, and collecting the larger subset into a container first might be slower than simply having a conditional operation embedding in the traversal istelf. For example, consider one might want to apply a function to the 2-simplices of the cofaces of a complex.  -->

<!-- Generating the set of cofaces (apriori) in a container might be slower than simply enumerating (and possibly applying a generic function to) the set of cofaces. -->

<!-- internally, simplices are not represented as integer vectors, but only contain the label of the _last_ vertex in the simplex. This, obviously, removes the redundancy of e.g. storing each face of a complex independently, but is more difficult to work to with. The idea of a traversal is that it enables primitive iteration     -->

<!-- ```{r} -->
<!-- st <- simplextree::simplex_tree() -->
<!-- st$insert(c(1, 2, 3)) -->
<!-- st$insert(c(2, 3, 4, 5)) -->


<!-- ## Traversals can be chained. Here's an example that prints the link of each vertex. -->
<!-- https://en.wikipedia.org/wiki/Iterator_pattern -->
<!-- print_link <- function(vertex){  -->
<!--   print(sprintf("Link of %d: %s", vertex, paste0(st$ltraverse(vertex, identity, "link"), collapse = ", "))) -->
<!-- } -->
<!-- st$traverse(NULL, print_link, "maximal-skeleton", list(k = 0)) -->
<!-- ``` -->
