---
title: "simplextree: Introduction"
output: html_notebook
---

## Introduction 

In the realm of Topological Data Analysis (TDA), often the foundational starting point in moving from a "data set" to some type of analysis of that data set is the construction of an (abstract) [simplicial complex](https://en.wikipedia.org/wiki/Simplicial_complex). There are many constructions provide either certain theoretical or computational guarentees, and the choice of construction generally depends on the goal of analysis: for example, the ÄŒech and Rips are complexes are often used in studying Persistent Homology, Nerve complexes (such as the Mapper) are often used to group areas of the space together to yield computationally simpler representations, Delaunay complexes are generally used in mesh-generation, etc. Each construction admits a certain intrinsic complexity: for example, the Rips complex at parameter $\epsilon$ admits a face for every subset of points which have diameter less than $\epsilon$, the Witness complex[^2] scales according to the number of specified landmarks, etc. Although these constructions are in practice very different from each other, they all satisfy the general definitions of being simplicial complexes: they are all higher order graph like representations that are closed under taking faces. It would be nice to have a simple, elegant data structure capable of representing any simplicial complex, without being tied to a specific construction process. 

Enter the _simplex tree_[^1]: a flexible and efficient data structure for representing and manipulating general simplicial complexes of any dimension. The best and quickest way to understand the simplex tree structure is with a picture. Here's one (taken from the paper) depicting a simplicial 3-complex (left) and its corresponding Simplex Tree (right). Each node is in bijection with the faces in the complex: there exactly one node for each face, and each node stores exactly one label.

![simplex tree figure\label{st_pic}](man/figures/simplextree.png)

The simplex tree can be effectively be thought of as an ordered [Trie](https://en.wikipedia.org/wiki/Trie), a related tree-like data structure that has proven useful in storing and processing words/text corpora. Like a trie, the simplex tree stores just one 'character' per node (+ a constant number of extra pointers to maintain the adjacency structure), and each node is associated with with exactly one face in the complex. Unlike a traditional trie, however, the simplex tree respects a certain ordering requirement wherein children must have labels with values greater than their parents. Additionally, each level beyond dimension $0$ stores additional indexes mapping `cousins', or nodes at the the same label and depth. These relatively simple constraints allow the data structure to scale relatively well in size and dimension---inline with the intrinsic complexity of construction needed---without restricting the type of construction represented. 

In what follows, for those interested, I will discuss how some common operations used in tandem with simplicial complexes can be greatly simplified using the simplex tree. I'll also discuss their associated complexities, and give examples of how to execute such operations using the `simplextree` package. 

## Getting started 

To get started with the `simplextree` package, one needs a method of constructing a simplicial complex. One option is to start with an empty complex and build it manually.

```{r}
library(simplextree)
st <- simplex_tree()
print(st)
```

On the _R_ side, each $k$-simplex is represented as a $(k+1)$-length integer vector containing the labels of the simplex. Inserting simplices into the complex can be done one at a time or specified as a collection via a list, either through the `insert` function or at initialization time via `simplex_tree`. For example, one way to build the triangle $\{1,2,3\}$ is to insert each simplex one-by-one:

```{r}
st <- simplex_tree()
insert(st, 1)
insert(st, 2)
insert(st, 3)
insert(st, c(1,2))
insert(st, c(1,3))
insert(st, c(2,3))
insert(st, c(1,2,3))
```

In inserting a simplex $\sigma$, to conform to the properties of being a simplicial complex, all faces of $\sigma$ must also being inserted. Thus, its sufficient to specify just the maximal faces, i.e. the simplices which are not themselves faces of any other simplex. The same code above reduces to: 
```{r}
st <- simplex_tree()
insert(st, c(1,2,3))
```

For example, the complex above has ten 0-simplices, twelve 1-simplices, six 2-simplices, and one 3-simplex, but to construct it all one needs to do is insert the simplices $\{1,2,3\}$, $\{2,3,4,5\}$, $\{6,7,9\}$, $\{7,8\}$, and $\{10\}$.

```{r}
st <- simplex_tree()
insert(st, list(c(1,2,3), c(2,3,4,5), c(6,7,9), c(7,8), c(10)))
print(st)
```

You can also supply the simplices at initialization. 
```{r}
st <- simplex_tree(list(1:3, 2:5, c(6,7,9), 7:8, 10))
print(st)
```

### Detour: Side-effects

note that `insert` inserts the given simplex(es), and then returns the complex invisibly. That is, `insert` (and many other functions) enact *side-effects*, wherein the underlying object is changed. No copies are made. This can be surprising to some `R` users, who are used to each and every line effectively being independent from the last.

```{r}
st2 <- st
insert(st, 11)
print(st)
print(st2)
```
Notice that modifying `st` after also affects `st2`. This happens because `<-` does not create a copy in this case; `st` and `st2` are references to the same underlying object. You can create a new copy with e.g. `st2 <- clone(st)`. Note this only copies the simplices themselves; nothing else. 

Methods which modify the underlying `simplextree` object follow the same pattern: the first argument is always the complex, and the function always returns the modified object invisibly. This allows many operations which modify the complex to be chained, e.g. yet another way of achieving the insertions above would be to do something like `st %>% insert(c(1,2,3)) %>% insert(c(2,3,4,5)) %>% ...`, etc. This pattern is known as [method chaining](https://adv-r.hadley.nz/r6.html#method-chaining), and has grown commonplace in the [tidyverse](https://www.tidyverse.org/) collection of packages. 

You can use the _tree_ and _cousins_ options of the `print_simplices` method to see the structure of the underlying simplex tree, the former showing the subtrees rooted at each vertex per line (top-down), and the latter showing how the simplices are stored per level (from the side):
```{r}
print_simplices(st, "tree")
```
Another way is to just plot the complex, usually with some well-chosen coordinates
```{r, fig.width=3, fig.height=3}
st <- simplex_tree(list(1:3, 2:5, c(6,7,9), 7:8, 10))
coords <- cbind(x=c(57,451,336,620,677,1077,1359,1400,845,990), y=c(305,158,354,589,247,346,200,491,152,612))
plot(st, coords=coords, asp = 1)
```

Other ways to modify or query the complex follow a similar interface, e.g. `remove(st, 1:2)` removes the simplices $\{1\}$, $\{2\}$, and $\{1, 2\}$, `find(st, 1:2)` returns whether $\{1,2\}$ exists in the complex, etc. For examples of these functions, see the index page `?simplextree` and all the corresponding methods. 

### Traversals

If simplices are the atoms from which the simplex tree is created, then traversals are the building blocks from which higher order operations and algorithms on the complexes are formed. A *traversal* is an ordered path through a subset of the simplices in the simplex tree. As will be shown below, they form the foundation for many other auxiliary methods, and they often provide elegant starting point when one is tasked with writing an efficient algorithm involving a simplicial complex. 

Each traversal requires as its first argument the complex through which to traverse. Some traversals support other arguments, e.g. where to start the traversal from, which simplices to include as 'part' of the traversal path, etc. Given a parameterized traversal, the `traverse` function accepts as its first argument the complex and as its second argument the function to invoke on each simplex. To get started, for example, consider the classical _preorder_ ("depth-first") traversal.

```
preorder(node){
  if (node == null)
    return
  visit(node)
  for child_node of node.children
    preorder(child_node)
}
```

Straightforward. On the simplex tree, a preorder traversal can be printed concisely as shown below with the `print_simplices` utility function. 

```{r}
## Prints the simplices of each traversal column-wise, i.e. each simplex is a column 
print_simplices(preorder(st), format = "column")
```
Notice that, due to the naturally ordered structure of the simplex tree, the preorder corresponds to a [lexicographical ordering](https://en.wikipedia.org/wiki/Lexicographical_order) of the simplices in the complex. Similarly, the level order (not shown) corresponds with the [shortlex](https://en.wikipedia.org/wiki/Shortlex_order) order (i.e. lexicographical per dimension). A related property one can extract from this observation is that every ancestor simplex (a simplex with children) in the trie must be a face of any of its descendants, and similarly every descendant simplex must be a coface of its ancestors. This naturally constructive property can come in handy in crafting efficient algorithms for manipulating the complex. Let's see some examples of this in action. 


### Fundamental building blocks

As a warmup, consider the problem of enumerating all the simplices in the complex. A starting stragety might be to represent full complex as a simple list of simplices $L = \{ \sigma_1, \sigma_2, \dots, \sigma_m \}$, where each entry contains an individual face of the complex. For example, a 2-simplex $\{1, 2, 3\}$  as a full simplicial complex $\mathcal{K}$ might be represented with the list $L = \{1, 2, 3, \{1, 2\}, \{1, 3\}, \{2, 3\}, \{1, 2, 3\} \}$. Since the simplices are already formed, enumerating this list takes linear time $O(m)$, where $m$ is the number of simplices in the list; however, notice many of the labels stored are redundant---this list takes loosely $O(md)$ space, where $d = \mathrm{dim}(\mathcal{K})$ is the dimension of the largest face in the complex. Things don't improve when the dimensions increase. 

Alternatively, suppose we have happen to have the 'largest' simplices on hand, i.e. the largest simplices whose union captures the full complex. The space needed to store the complex is obviously much lower now, but enumerating faces in the complex require forming lower order faces on demand. For example, going back to the example from the picture\ref{st_pic}, one can store just the maximal faces and then enumerate the lower-order ones with the highly useful `combn` function: 

```{r}
simplices <- list(c(1,2,3), c(2,3,4,5), c(6,7,9), c(7,8), 10)
for (simplex in simplices){
  d <- length(simplex)
  for (k in 1:d){
    combn(d, k, function(i){ print(simplex[i]) })
  }
}
```
This is a nice, compact way of storing a complex, but it has some drawbacks. Firstly, it assumes that ones has these 'largest' simplices on hand. More importantly, there's little structure here: generating the actual vectors containing the labels of each simplex requires forming a new simplex at each iteration of the inner loop (via `simplex[i]`). For a $k$-simplex, this requires at least $(k+1)$ operations, leading to a loose complexity of $\approx O(md)$, where again $m = \lvert \mathcal{K} \rvert$ represents is the number of simplices in $\mathcal{K}$ and $d = \mathrm{dim}(\mathcal{K})$ the dimension. 
So one approach uses $O(md)$ storage and then allows $O(m)$ complexity on enumeration, and the other compresses the complex to use $O(m)$ storage, but then requires $O(md)$ time to enumerate faces. The proverbial "you can't have your cake and eat it too" seems to ring true. 

Instead, consider again the enumeration problem using the simplex tree using, e.g. the *preorder* traversal. As mentioned above, this corresponds to the lexicographical ordering of the faces.  
```{r}
## Prints the simplices of each traversal column-wise, i.e. each simplex is a column 
print_simplices(preorder(st), format = "column")
```
Observe that in the sequence of simplices printed above, at most one label and at most one dimension changes per visited node. Imagine keeping just one vector around in memory, which is to be populated with the labels of the current node. In going from a $k$-simplex to a $(k+1)$-simplex, the vector has a new label appended and increases in size by 1, but all other labels are unaffected (and are correct). Similarly, in traversing upwards from $(k+1)$-simplex to a $k$-simplex, the vector shrinks by 1 and has its last label modified. Regardless, the time it takes to form the labels corresponding to a simplex is constant: one size change, and one label change. Thus, enumerating the simplices with a preorder traversal takes linear time $\approx O(m)$ in the size of complex. And since each node stores only one label, we achieve an $\approx O(m)$ size as well.

<!-- One could just write a new algorithm from scratch: visit each node in the trie (somehow), and at each node $\eta$, traverse upwards from $\eta$ towards the root, recording the individual labels for each node along the way to create the labels forming the full $k$-simplex.  -->


```{r}
st1 <- simplex_tree(list(c(1,2,3), c(1,2,4,5)))
st2 <- simplex_tree(list(c(1,3,4), c(2,3,4,5)))
as.list(maximal(st))
```


### Building from the blocks

Now consider a slightly modified version of the warmup above: create a function to enumerate the $k$-skeleton of $\mathcal{K}$: the set of simplices of dimension $\leq k$. How would you do it?  

Easy way out: just enumerate all the simplices, keeping only those with dimension $\leq k$. 
```{r}
k <- 2
skeleton <- list()
traverse(preorder(st), function(simplex){
  if (length(simplex) <= (k+1)){
    skeleton <<- append(skeleton, list(simplex))
  }
})
print_simplices(skeleton, format = "column")
```
The problem: what if $\mathrm{dim}(\mathcal{K}) >> k$? Since the majority of the simplices will have lengths $> k$, the majority of the time will be spent enumerating subtrees corresponding to simplices that will never be needed. This may seem like a trivial concern, but simplicial complexes are frequently built from representations that are inherently combinatorial. One of the unfortunate consequences of this is that they often scale exponentially in size, and as a result what appears to be a trivial concern may turn out to be a very nontrivial computational problem.

Consider the popular [Rips complex](https://en.wikipedia.org/wiki/Vietoris%E2%80%93Rips_complex), which is a geometric [flag complex](https://en.wikipedia.org/wiki/Clique_complex), i.e. a simplicial complex whose higher order simplices are determined by the $1$-skeleton entirely. An easy way of getting a random Rips complex is to first form a graph by e.g. sampling $n$ points from the unit square, connecting points pairwise with an edge if they are within distance $2 \epsilon$ of each other. The Rips complex is up to dimension $k$ can be recovered by inserting higher order cliques via e.g. an _expansion_ algorithm. But how quickly does the complex grow in this scheme, based on this parameter $\epsilon$?

```{r}
set.seed(1234)
for (eps in seq(0.10, 0.50, by=0.10)){
  G <- igraph::sample_grg(nodes = 35, radius = eps)
  st <- simplex_tree(as.list(seq(vcount(G)))) %>% insert(t(igraph::as_edgelist(G)))
  st %>% expand(k=max(st$degree(st$vertices)))
  cat(sprintf("Parameter=%g, n_simplices=%d:\n", eps, sum(st$n_simplices)))
  print(structure(st$n_simplices, names=seq(0, st$dimension)))
  cat("\n")
}
```
Even though there are only 35 points, by the time the radius parameter is $0.5$, the complex already has over 24 thousand simplices, of which less than 2\% have dimension $\leq 2$! 

If one just wants the enumerate the $k$-skeleton of the complex, filtering out higher-order simplices isn't enough: the traversal should not recurse beyond dimension $k$. The fix is easy enough:

```
preorder(node, k){
  if (node == null)
    return
  visit(node)
  if (node.dimension < k){
    for child_node of node.children
      preorder(child_node, f)
  }
}
```

You can enumerate the $k$-skeleton of a complex like so with the `simplextree` package. 
```{r}
st <- simplex_tree(list(1:3, 2:5, c(6,7,9), 7:8, 10))
print_simplices(st %>% k_skeleton(k = 2L), format = "column")
```

Enumerating the $k$-simplices follows a similar pattern: we skip nodes with dimension $< k$, and don't recurse beyond dimension $k$. The only changes to pseudocode above would be something like `if (node.dimension == k){ visit(node) }`. Of course, these traversal extensions are available in `simplextree`.  
```{r}
st <- simplex_tree(list(1:3, 2:5, c(6,7,9), 7:8, 10))
print_simplices(st %>% k_simplices(k = 2L), format = "column")
```
Concluding this warmup, we've seen that in starting with some very standard algorithms (i.e. a preorder/"depth-first" tree traversal) on the simplex tree data structure, it is straightforward derive efficient algorithms to perform common operations sought after in interacting with a simplicial complex. 

### Enumerating cofaces 

Recall the any abstract simplicial complex $\mathcal{K}$ is closed under taking faces: for every $\sigma \in \mathcal{K}$, if $\tau \subseteq \sigma$, then $\tau$ must also be in $mathcal{K}$. If $\tau \subseteq \sigma$, $\tau$ is said to be a _face_ of $\sigma$. This definitions has a dual as well: if $\tau \subseteq \sigma$, then $\sigma$ is said to be a _coface_ of $\tau$. That is, the set faces/cofaces of $\sigma$ are the simplices $\tau$ satisfying, respectively:  
$$ \text{faces}(\sigma) = \{\tau \in \mathcal{K}, \tau \subseteq \sigma \}$$
$$ \text{cofaces}(\sigma) = \{ \, \tau \in \mathcal{K}, \, \sigma \subseteq \tau \, \}$$
In both definitions, $\sigma$ is itself both face and coface of itself. As shown above, enumerating the faces of a simplex is easy enough: given a $(d+1)$-simplex, one can enumerate all $k$-length combinations where $k \leq d + 1$ with `combn`: 

```{r}
sigma <- c(1,2,3,4)
d <- length(sigma)
faces <- lapply(1:d, function(k){
  combn(d, k, FUN = function(i){ sigma[i] }, simplify = FALSE)
})
faces <- unlist(faces, recursive = FALSE) ## flatten one layer deep 
print_simplices(faces, format = "column")
```

This doesn't even require a simplex tree structure (after all, given $\sigma$, its faces _must_ be in the trie, by the definition of a simplicial complex). But now consider the problem of computing cofaces. How would you go about doing it naively, i.e. with just a list of simplices?

One way, of course, is to just enumerate all the simplices in the complex, and just record which ones contain $\sigma$ as a subset. But this takes $\approx O(2md)$ comparisons, where $m = \lVert \mathcal{K} \rVert$, and $d = \mathrm{dim}(\mathcal{K})$. There is a more efficient way. 

If one wants to find the cofaces of $\sigma = \{v_1 v_2 \dots v_k\}$, then any simplex $\tau \in \mathcal{K}$ with labels of the form $\{\ast v_0 \ast v_1 \ast \dots \ast v_k \ast \}$ counts as a coface, where $\ast$ is any vertex label (or empty) in $\mathcal{K}$. To decompose the problem into simpler steps, first consider finding simplices with labels $\{\ast v_0 \ast v_1 \ast \dots \ast v_k \}$. Since we are looking for cofaces, we only need consider simplices whose dimensions are greater than $\sigma$, and since these particular simplices end in $v_k$, they must be encoded in the adjacency relations linking 'cousins' at the same depth (in the picture shown above, the 'cousins' nodes recording the $5$ label are linked). 

We now exploit the face/coface property, as before. Since every coface $\tau$ of a given simplex $\sigma$ must include $\sigma$ itself, we explicitly look at dimensions higher than $\mathrm{dim}(\sigma)$. Similarly, since every ancestor is face of its descendants, all of the descendants of $\sigma$ are cofaces of $\sigma$. Thus, only the nodes representing the roots of these subtrees are needed to fully describe the cofaces. 

For example, consider computing the cofaces of the vertex $\sigma = \{3\}$. Every descendant of the subtree rooted at $\{3\}$ is a coface, so to start we need only record $3$. Then we check the _cousins_ at a higher depth with the same label. Here's a print out of all the cousins and their corresponding keys (as pairs):

```{r}
st$print_cousins()
```
We see immediately see that cofaces $\{ 1 3 \}$ and $\{ 2 3 \}$ occur at depth 2, and coface $\{ 1 2 3 \}$ occurs at depth $3$. The first and third of those have no descendants, but the second ($\{ 2 3 \}$) has three. Thus, we can record all the cofaces of $\{3\}$ (of which there are 10) using just 4 simplices by just recording the roots. The roots can be used in  composition with any other traversal (e.g. a preorder traversal) to enumerate the cofaces as needed. Here's the code to show exactly that using the `coface_roots` traversal: 

```{r}
print_simplices(coface_roots(st, 3))
```
Then, to print the cofaces of ${3\}$
```{r}
print_preorder <- function(simplex){ print_simplices(simplex %>% preorder(st, .)) }
st %>% 
  coface_roots(3) %>% 
  traverse(print_preorder)
```

To expand the lower-order faces automatically, use the `cofaces` traversal directly: 
```{r}
print_simplices(cofaces(st, 3))
```

## Example 2: maximal faces

Now consider the problem of enumerating the *maximal faces* of a complex. A _maximal face_ $\sigma \in \mathcal{K}$ is a simplex that not a face of any other simplex in $\mathcal{K}$. Such simplices correspond with the 'largest' simplices previously mentioned; they are also the simplices used in the `simplextree` constructor below. 

```{r}
st <- simplex_tree(list(1:3, 2:5, c(6,7,9), 7:8, 10))
coords <- cbind(x=c(57,451,336,620,677,1077,1359,1400,845,990), y=c(305,158,354,589,247,346,200,491,152,612))
plot(st, coords=coords, asp = 1)
```
In order of dimension, they are $\{10\}$, $\{7,8\}$, $\{6,7,9\}$, $\{1,2,3\}$, and $\{2,3,4,5\}$. How might go about finding them? 

By the definition of a simplicial complex, if a simplex $\sigma \in mathcal{K}$ is not a face of any other simplex in $\mathcal{K}$, then _it has no cofaces_, aside from itself. Thus, we should be able to just enumerate all the simplices in the complex---for each simplex $\sigma$, we check to see how many cofaces it has. If it has only one (itself), it must be maximal. We have a way of traversing the complex efficiently (preorder), and we have an efficient means of enumerating the cofaces for any given simplex. 
```{r}
maximal_faces <- list()
traverse(preorder(st), function(sigma){
  sigma_cofaces <- as.list(cofaces(st, sigma))
  if (length(sigma_cofaces) == 1){
    maximal_faces <<- append(maximal_faces, list(sigma))
  }
})
print_simplices(maximal_faces)
```
Sure enough, this works, but it can be made even more efficient: for each $\sigma \in \mathcal{K}$, rather than enumerating all the cofaces, it is enough to just check whether $\sigma$ has _any_ cofaces aside from itself. To do that, note that if $\sigma$ has any children, it is not maximal, and otherwise the only thing left to do is check if $\sigma$'s label exists anywhere in the tree at a depth greater than $\mathrm{depth}(\sigma)$. Checking the existence of a given label at any depth can be done by looking at the cousins: at depth $k$, if there are $m$ simplices, then this should take at most $O((d-k) \log (m-k))$ time. To see this, consider the worst case scenario where one has a fully connected $4$-complex:
```{r}
st <- simplex_tree(1:5)
st$print_cousins()
```
Suppose one wants to check if there exists a $k$-simplex $\{v_0, v_1, \dots, v_{k}\}$ with last label $v_k$ in the complex. In the above complex, note there are $m-1$ $1$-simplices, and $m-2$ $2$-simplices, etc. Since the labels kept in an ordered structure, checking the existence of a $k$-simplex (with some fixed label) takes at most $\log(m-k)$ searches (using e.g. a binary search). Back to the problem of detecting whether $\sigma$ has any cofaces, since we need only check dimensions higher than $\dim(\sigma) = k$, this leads to a worst case complexity of $O((d-k)\log(m-k))$ (for $m = \lVert \mathcal{K} \rVert$, and $d = \mathrm{dim}(\mathcal{K})$). In practice, $d << m$, making the check effectively an $\approx O(m)$ operation. Since the preorder enumeration takes time linear in the size of the complex, finding the maximal faces of a given complex can be done in effectively sub-quadratic time. Of course, this traversal has also been optimized in in C++; you can enumerate the maximal simplices using the `maximal` traversal:

```{r}
st <- simplex_tree(list(1:3, 2:5, c(6,7,9), 7:8, 10))
print_simplices(st %>% maximal())
```

## From maximal faces to cliques

A *k-clique* is a complete subgraph that has $k$ vertices, i.e. a subgraph if called a *k-clique* there exists an edge between every combination of $k$ vertices. A *maximal* clique is a clique that cannot be extended by adding another vertex--intuitively, they can be thought of as the 'largest' complete subgraphs which, when unioned together, yield the graph one started with. A simplicial complex may or may not have a $k+1$-simplex for every maximal cliques; for example the open triangle $\mathcal{K} = \{1, 2, 3, \{1,2\}, \{1,3\}, \{2,3\}\}$ has as its maximal simplices $\{\{1,2\}, \{1,3\}, \{2,3\}\}$, while it's maximal clique is the simplex $\{1,2,3\}$. 

```{r}
st <- simplex_tree(combn(3,2))
print_simplices(st)
print_simplices(maximal(st))
```

It is not possible to enumerating the maximal cliques in polynomial time by virtue of the fact the number of maximal cliques within a graph is exponential in size: given a graph with $n$ vertices, the graph may have up to $3^{n/2}$ maximal cliques in the worst case. Output sensitive algorithms exist, such as the Bron-Kerbosch family of algorithms[1], however they essentially all begin with the assumption that the input is a graph (as opposed to a simplicial complex). Finding cliques is important for many areas of scientific computing and also has many applications in TDA, as many constructions depend on them. For example, one way of building the Rips complex up to dimension $k$ is to simply start with the 1-skeleton (graph), and then enumerate the lower order $k$-simplices of all the maximal cliques.

Let's see ways of approaching this problem that uses the simplex tree structure. Instead of the maximal-clique problem, I'll consider the smaller problem of enumerating all maximal cliques _up to dimension k_. That is, we consider a clique to be maximal only if it involves $k$-vertices or less. First, recall the example complex used above: 

![simplex tree figure](man/figures/simplextree.png)

In this case, the maximal cliques actually do correspond with the maximal faces of the complex, so instead suppose we only have the graph of this complex:

```{r}
coords <- cbind(x=c(57,451,336,620,677,1077,1359,1400,845,990), y=c(305,158,354,589,247,346,200,491,152,612))
edge_pairs <- function(simplex){ combn(length(simplex), 2, function(i){ simplex[i] }) }
edges <- do.call(cbind, list(edge_pairs(1:3), edge_pairs(2:5), edge_pairs(c(6,7,9))))
st <- simplex_tree(edges) %>% insert(list(7:8, 10))
plot(st, coords=coords, asp = 1)
```
The $k$-cliques correspond set of $k$ vertices which are all pairwise connected. In the above example, the $k=3$ cliques correspond to the complete subgraphs formed from the vertices $\{1,2,3\}$, $\{2,3,4\}$, $\{2,4,5\}$, $\{3,4,5\}$, $\{2,3,5\}$, and $\{6,7,9\}$. How can we detect these cliques? It is not at all clear how to do so efficiently.

Let's look more at the trie structure of the simplex tree. 
```{r}
print_simplices(st, "tree")
```

Consider how one would go about detecting the clique ${1, 2, 3}$. Starting at vertex $\sigma = \{1\}$, we might start by detecting $\sigma$'s neighbors. By the construction of the simplex tree, if another vertex $\sigma'$ is adjacent to $\sigma$ and its label is greater than $\sigma$'s label, it must be a child of $\sigma$. We know that we can form the 2-simplex ${1, 2, 3}$ if and only if we have all edges accounted for; we see that ${1}$ has children nodes with labels ${2}$ and ${3}$, indicating edges $\{1,2\}$ and $\{1,3\}$ are accounted for. Since no simplex has a label greater than $1$, this covers all of $\{1\}$'s edges. We descend to recurse at the node representing the simplex $\{1, 2\}$. The label stored in the node is $2$. Again, the neighbors of the vertex $\{2\}$ whose labels are greater than $2$ are exactly its children nodes---so if we intersect the previously accounted labels ($2$ and $3$) with $\{2\}$'s children labels, any labels in their common intersection represents an intersection of three pairwise edges, and we know we have detected a clique. Since the labels of any set of children are ordered, this problem computationally reduces to computing the intersection between two sorted ranges, which can be efficiently done in time linear in the size of the ranges using e.g. [std::set_intersection](https://en.cppreference.com/w/cpp/algorithm/set_intersection).

One can deduce a recursive procedure for proceeding with the rest of the complex. For every detected $k$-clique, we may choose to insert a $(k-1)$-simplex back into complex, thus 'expanding' the complex. Doing this for all simplices in the complex is what's called _expansion of order k_, or _k-expansion_ for short.

```{r, echo = FALSE}
st <- simplex_tree(edges) %>% insert(list(7:8, 10))
```

We can see which simplices were inserted via asymmetric difference
```{r}
s1 <- as.list(st %>% level_order())
s2 <- as.list(st %>% expand(k = 2) %>% level_order())
print_simplices(setdiff(s2,s1))
```

Or better, by plotting it.
```{r}
st %>% 
  expand(k = 2) %>% 
  plot(coords=coords, asp = 1)
```

## TDA application example 2. Computing the Rips complex 

<!-- As a simple example to get started, below are three separate ways of printing the simplices in the complex in a [preorder](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)) traversal.  -->

<!-- ```{r, echo=FALSE} -->
<!-- ## (explicit) -->
<!-- traversal <- preorder(st) -->
<!-- traverse(traversal, function(simplex){  -->
<!--   print(simplex)  -->
<!-- }) -->

<!-- ## (short) -->
<!-- traverse(preorder(st), print) -->

<!-- ## (tidyverse style) -->
<!-- st %>%  -->
<!--   preorder() %>%   -->
<!--   traverse(print) -->
<!-- ``` -->

<!-- They are all equivalent, but follow different styles of R programming. To keep up with the more modern way of writing R, I'll use the tidyverse-style of composing operations with [magrittr](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) pipes.  -->


```{r}
e <- new.env(parent = emptyenv())
sigma <- c(3, 4)
traverse(preorder(st), function(tau){ 
  if (all(sigma %in% tau)){
    e$cofaces <- append(e$cofaces, list(tau))
  }
})
```


```{r}
e <- new.env(parent = emptyenv())
e$max_depth <- 0L
traverse(preorder(st), function(sigma){ 
  
  e$max_depth <- max(c(e$max_depth, length(sigma)))
})


```





```{r}

library(simplextree)



simplices <- list(list(1,2), list(3,4,1:2,2:3), list(3:4,c(1,4)), list(c(1,3)), list(1:3), list(c(1,3,4)))
layout(matrix(1:6, nrow=2, byrow=TRUE))
st <- simplex_tree()
for (sigma in simplices){
  st %>% 
    insert(sigma) %>% 
    plot(text_opt=list(labels=letters[st$vertices]))
}

st %>% insert(as.list(1:5)) %>% plot()
st %>% insert(combn(1:5, 2, simplify = FALSE)) %>%  plot() 
st %>% insert(1:3) %>% plot()
  


e <- new.env(parent = emptyenv())
e$max_depth <- 0L
combn(4:6, 2, function(tau){ max(tau) })
traverse(preorder(st), function(sigma){ 
  
  e$max_depth <- max(c(e$max_depth, length(sigma)))
})
```

## Example 3. Computing the Euler characteristic curve on a sliding window

```{r}
sapply(maximal(st), function(sigma){ 
  combn(sigma, length(sigma), FUN = function(cc){ })
})
```

```{r}
remove.packages("simplextree")


G <- igraph::sample_grg(20, 0.20, coords = TRUE)

st <- simplex_tree(as.list(1:igraph::vcount(G)))
insert(st, igraph::as_edgelist(G))
st$expand(2)
xy <- with(igraph::vertex.attributes(G), {
  cbind(x,y)
})


jsonlite::toJSON(list(nodes=1:igraph::vcount(G), edges=st$edges, polygons=list(st$triangles)))
simplices <- list(coords = xy, nodes=letters[1L:(igraph::vcount(G)-1L)], edges=st$edges-1L, polygons=list(st$triangles-1L, st$quads-1L))
wut <- jsonlite::toJSON(simplices, pretty = TRUE, auto_unbox = FALSE)

microbenchmark::microbenchmark({
  st$expand(2)
}, setup = {
  st <- simplex_tree(as.list(1:igraph::vcount(G)))
  insert(st, igraph::as_edgelist(G))
})

# Unit: milliseconds
#                  expr      min       lq     mean   median       uq      max neval
#  {     st$expand(2) } 3.494911 3.747423 4.521941 3.956999 4.147819 11.60263   100


microbenchmark::microbenchmark({
  st$expand(2)
}, setup = {
  st <- simplex_tree()
  st$insert(as.list(1:igraph::vcount(G)))
  E <- igraph::as_edgelist(G)
  edges <- lapply(1:nrow(E), function(i){ E[i,] })
  st$insert(edges)
})
# Unit: milliseconds
#                  expr      min       lq    mean   median       uq      max neval
#  {     st$expand(2) } 63.03884 64.60097 65.9168 65.68367 66.79374 76.15908   100
```


## Conclusion 

In summary, the simplex tree provides an efficient data structure for manipulating simplicial complexes that balances scalability and generality. While other structures may more be better suited to specific families of constructions, the skeleton-blockers or tidy set data structures for encoding flag complexes, the delaunay complex for surface mesh generation, etc., the simplex tree lies at an abstraction scale between the specialized constructions and the "simple" solution using just a list. As shown above, the structure in many ways is a natural structure for representing general simplicial complexes.

## References 
[^1]: Boissonnat, Jean-Daniel, and ClÃ©ment Maria. "The simplex tree: An efficient data structure for general simplicial complexes." Algorithmica 70.3 (2014): 406-427.

[^2]: De Silva, Vin, and Gunnar E. Carlsson. "Topological estimation using witness complexes." SPBG 4 (2004): 157-166.